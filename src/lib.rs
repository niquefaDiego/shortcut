use {
    config::{Config, ConfigAddResult, ConfigRemoveResult},
    std::path::{Path, PathBuf},
};

pub mod config;
pub mod fs;
pub mod shell;

fn get_bat_file_content(config: &Config) -> Vec<String> {
    let mut x: Vec<String> = vec![];
    x.reserve_exact(15 + 2 * config.shortcuts.len());
    x.push(":: Script auto-generated by `$ shortcut setup`.".to_string());
    x.push(":: See `$ shortcut -- help` for more info.".to_string());
    x.push("@ECHO OFF".to_string());
    x.push("IF \"%1\"==\"+\" (".to_string());
    x.push("    SHIFT".to_string());
    x.push("    shortcut add %*".to_string());
    x.push(") ELSE IF \"%1\"==\"-\" (".to_string());
    x.push("    SHIFT".to_string());
    x.push("    shortcut remove %*".to_string());
    x.push(") ELSE IF \"%1\"==\"*\" (".to_string());
    x.push("    SHIFT".to_string());
    x.push("    shortcut list %*".to_string());
    for shortcut in &config.shortcuts {
        x.push(format!(") ELSE IF \"%1\"==\"{}\" (", shortcut.key).to_string());
        x.push(format!("    CD /D \"{}\"", shortcut.value).to_string());
    }
    x.push(") ELSE (".to_string());
    x.push("    CD /D %1".to_string());
    x.push(")".to_string());
    x
}

fn create_or_update_executable_bat(config: &Config) -> Result<(), String> {
    let file_name = config.command.to_string() + ".bat";
    let file_path = Path::new(&config.path_location).join(file_name);
    let file_content = get_bat_file_content(config);
    fs::write_lines(&file_path, file_content)
}

pub fn setup(command: String, path_location: PathBuf) -> Result<(), String> {
    let config = config::create_config(&command, &path_location)?;
    let shells = shell::supported_shells();
    if shells.len() == 0 {
        println!(
            "No supported shells found. \
            Currently only PowerShell and Command Prompt are supported"
        );
        return Ok(());
    }
    // When adding support for linux we don't need the bat file, so this would not be needed.
    create_or_update_executable_bat(&config)?;
    for shell in shells {
        if shell.available()? {
            shell.setup(&command)?;
        }
    }
    Ok(())
}

pub fn list() -> Result<(), String> {
    let config = config::get_config()?;
    println!("Command: \"{}\"", config.command);
    println!("Shortcuts ({}):", config.shortcuts.len());
    for shortcut in &config.shortcuts {
        let text = format!("  {} -> {}", shortcut.key, shortcut.value);
        println!("{}", text);
    }
    Ok(())
}

pub fn add(key: String, target: PathBuf) -> Result<(), String> {
    let target = fs::to_absolute_path(&target)?;
    let target = target.to_string_lossy();
    let (config, add_result) = config::add_shortcut(&key, &target)?;
    create_or_update_executable_bat(&config)?;
    match add_result {
        ConfigAddResult::NoChange => println!(
            "Nothing done, shortcut already exists: {} -> {}",
            key, target
        ),
        ConfigAddResult::Created(sc) => {
            println!("Successfully added shortcut: {} -> {}", sc.key, sc.value)
        }
        ConfigAddResult::Updated(existing, added) => {
            println!("Successfully updated shortcut.");
            println!(
                "Existing shortcut was: {} -> {}",
                existing.key, existing.value
            );
            println!("New shortcut is: {} -> {}", added.key, added.value);
        }
    };
    Ok(())
}

pub fn remove(key: String) -> Result<(), String> {
    let (config, remove_result) = config::remove_shortcut(&key)?;
    create_or_update_executable_bat(&config)?;
    match remove_result {
        ConfigRemoveResult::NotFound => println!("Did not find any shortcut for key \"{}\"", key),
        ConfigRemoveResult::Removed(removed) => {
            println!(
                "Successfully removed shortcut {} -> {}",
                removed.key, removed.value
            )
        }
    }
    Ok(())
}

pub fn get(key: String) -> Result<(), String> {
    let config = config::get_config()?;
    if Path::new(&key).is_dir() {
        println!("{}", key);
        return Ok(());
    }
    for shortcut in &config.shortcuts {
        if key == shortcut.key {
            println!("{}", shortcut.value.clone());
            return Ok(());
        }
    }
    println!("{}", key);
    Ok(())
}
